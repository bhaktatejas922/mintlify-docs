---
title: "Text Selection + Document Editing with Plate.js + Morph"
description: "Build lightning-fast text transformation features using Morph Apply with Plate.js rich text editors"
---
- **10x Faster**: Apply edits at 2000+ tokens/second vs 200 tokens/second
- **Smart Integration**: Plate.js handles rich text, Morph handles transformations
- **Real-time Updates**: Stream changes as they happen

## Quick Start

Install dependencies:

```bash
npm install @udecode/plate-common @udecode/plate-markdown @udecode/plate-basic-nodes openai
```

Add your Morph API key:

```bash
MORPH_API_KEY=your_morph_api_key_here
```

## Simple Example: Morph API Route

Start with the core integration - a Morph API route that handles text transformations:

```typescript app/api/morph/route.ts
import OpenAI from 'openai';
import { NextRequest, NextResponse } from 'next/server';

const morph = new OpenAI({
  apiKey: process.env.MORPH_API_KEY!,
  baseURL: 'https://api.morphllm.com/v1',
});

export async function POST(request: NextRequest) {
  const { selectedText, transformation, fullDocument } = await request.json();

  // Morph applies transformation to the entire document
  const stream = await morph.chat.completions.create({
    model: 'morph-v2',
    messages: [{
      role: 'user',
      content: `<code>${fullDocument}</code>\n<update>${transformation} "${selectedText}"</update>`
    }],
    stream: true,
  });

  // Stream the response back for real-time updates
  const encoder = new TextEncoder();
  return new Response(new ReadableStream({
    async start(controller) {
      for await (const chunk of stream) {
        const content = chunk.choices[0]?.delta?.content || '';
        if (content) controller.enqueue(encoder.encode(content));
      }
      controller.close();
    },
  }));
}
```

## Plate.js + Morph Integration

Here's how they work together in a complete editor:

```tsx components/MorphEditor.tsx
'use client';

import { Plate, PlateContent, createPlateEditor } from '@udecode/plate-common/react';
import { MarkdownPlugin } from '@udecode/plate-markdown';
import { basicNodesPlugins } from '@udecode/plate-basic-nodes';
import { useState, useRef } from 'react';

export function MorphEditor() {
  const [editor] = useState(() => createPlateEditor({
    plugins: [...basicNodesPlugins, MarkdownPlugin],
  }));
  
  const [isTransforming, setIsTransforming] = useState(false);
  const [showMenu, setShowMenu] = useState(false);
  const [selectedText, setSelectedText] = useState('');
  const [menuPosition, setMenuPosition] = useState({ x: 0, y: 0 });

  const transformations = ['improve writing', 'simplify', 'make professional'];

  // Handle text selection
  const handleSelection = () => {
    const selection = window.getSelection();
    const text = selection?.toString().trim();
    
    if (text) {
      setSelectedText(text);
      const rect = selection!.getRangeAt(0).getBoundingClientRect();
      setMenuPosition({ x: rect.right, y: rect.bottom + 10 });
      setShowMenu(true);
    } else {
      setShowMenu(false);
    }
  };

  // Apply transformation using Morph
  const handleTransform = async (transformation: string) => {
    setIsTransforming(true);
    setShowMenu(false);
    
    // Get current document content from Plate.js
    const currentContent = editor.api.markdown.serialize();
    
    try {
      const response = await fetch('/api/morph', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          selectedText,
          transformation,
          fullDocument: currentContent
        })
      });

      // Stream the response and update Plate.js in real-time
      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let result = '';

      while (true) {
        const { done, value } = await reader!.read();
        if (done) break;
        result += decoder.decode(value);
        
        // Update Plate.js with streaming content
        const newNodes = editor.api.markdown.deserialize(result);
        editor.children = newNodes;
        editor.onChange();
      }
      
    } finally {
      setIsTransforming(false);
      window.getSelection()?.removeAllRanges();
    }
  };

  return (
    <div className="relative h-screen">
      <Plate editor={editor}>
        <PlateContent 
          className="h-full p-6 focus:outline-none"
          placeholder="Start writing... Select text to transform it."
          onMouseUp={handleSelection}
          onKeyUp={handleSelection}
        />
      </Plate>

      {/* Transformation Menu */}
      {showMenu && (
        <div
          className="fixed z-50 bg-white border rounded-lg shadow-lg p-2"
          style={{ left: menuPosition.x, top: menuPosition.y }}
        >
          <div className="text-xs text-gray-500 mb-2">
            Transform: "{selectedText.slice(0, 25)}..."
          </div>
          {transformations.map((transform) => (
            <button
              key={transform}
              onClick={() => handleTransform(transform)}
              className="block w-full text-left px-3 py-2 hover:bg-gray-100 rounded text-sm"
            >
              ✨ {transform}
            </button>
          ))}
        </div>
      )}

      {/* Loading State */}
      {isTransforming && (
        <div className="absolute top-4 right-4 p-3 bg-blue-100 rounded-lg text-blue-700">
          ⚡ Morph is transforming...
        </div>
      )}
    </div>
  );
}
```

## How It Works Together

1. **Plate.js** provides the rich text editing experience
2. **User selects text** → Menu appears with transformation options  
3. **Morph receives**: selected text + transformation + full document
4. **Morph returns**: completely updated document (not just the selection)
5. **Plate.js updates** with the new document content via markdown serialization

## Key Benefits of This Integration

**Fast Document Updates**: Morph processes entire documents at 2000+ tokens/second, while traditional approaches max out at ~200 tokens/second when applying changes.

**Streaming Experience**: Users see transformations happening in real-time instead of waiting for completion.

**Rich Text Preservation**: Plate.js maintains formatting while Morph handles content transformation.

## Advanced: Text Selection Component

For more precise selection handling, you can create a dedicated component:

```tsx components/SelectableText.tsx
'use client';

import { useState, useRef, useEffect } from 'react';

export default function SelectableText({ content, onTransform }) {
  const [selectedText, setSelectedText] = useState('');
  const [showPopover, setShowPopover] = useState(false);
  const [popoverPosition, setPopoverPosition] = useState({ x: 0, y: 0 });
  const contentRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleSelection = () => {
      const selection = window.getSelection();
      const range = selection?.getRangeAt(0);
      const text = range?.toString().trim();
      
      if (text && contentRef.current?.contains(range?.commonAncestorContainer)) {
        setSelectedText(text);
        const rect = range!.getBoundingClientRect();
        setPopoverPosition({
          x: rect.left + rect.width / 2,
          y: rect.bottom + window.scrollY + 10
        });
        setShowPopover(true);
      }
    };

    document.addEventListener('selectionchange', handleSelection);
    return () => document.removeEventListener('selectionchange', handleSelection);
  }, []);

  return (
    <div className="relative">
      <div ref={contentRef} className="p-4 border rounded-lg select-text">
        {content}
      </div>
      
      {showPopover && (
        <div
          className="fixed z-50 bg-white border rounded-lg shadow-lg p-2"
          style={{ left: popoverPosition.x, top: popoverPosition.y }}
        >
          <button onClick={() => onTransform(selectedText, 'improve')}>
            ✨ Improve writing
          </button>
        </div>
      )}
    </div>
  );
}
```

## Next Steps

Start with the basic integration above, then enhance with:
- Custom transformation types
- Undo/redo functionality  
- Multiple document formats
- Collaborative editing features

The combination of Plate.js rich text editing + Morph's lightning-fast document processing gives you both great UX and exceptional performance. 